---
title: "GitLab: Как безопасно доставать секреты в пайплайне"
date: 2025-11-22
draft: true
tags: ["GitLab", "OpenBao"]
---
Как правило, ни один пайплайн в GitLab, который работает со внешними ресурсами, не обходится без секретных данных, будь то токены, API ключи и так далее. Стандартное решение - это завести masked protected variables, но что если секретов много, и пайплайнов много, и хочется хранить их централизованно и максимально безопасно? Тогда есть смысл задуматься о хранилище секретов, таком как Hashi Vault или его форк с открытой лицензией OpenBao.
Возьмем в качестве примера OpenBao из-за его открытой лицензии.

Коротко вспомним о преимуществах централизованного хранилища секретов, такого как OpenBao:
1. Хранение секретов в одном месте уменьшает плоскость атаки. Лучше хранить секреты в одном максимально защищенном месте, чем в нескольких разнородных.
2. Если клиенты не хранят секреты у себя, можно осуществлять периодическую ротацию.
3. Удобно разграничивать доступ к секретам - клиенты получают доступ только к нужным секретам, а не ко всем.

### Быстрый старт с OpenBao

Начать щупать OpenBao в интересных местах просто:

```bash

```


## Извлечение секретов в пайплайне
Теперь переходим к главному вопросу: как же в пайплайне доставать секреты из OpenBao? Рассмотрим варианты.

### Постоянный токен
Самый простой и дубовый способ. Сгенерировать токен на доступ к секретам и положить его в защищенную переменную в GitLab CI/CD. Токен создается командой:

```bash
bao token create -ns=my -policy=my-policy
```
Здесь мы ограничиваем область действия токена только одним namespace `my` и ограничиваем возможности при помощи заранее созданной политики `my-policy`.

**Недостатки**:
* Токен может быть скомпроментирован в пайплайне. Если это произойдет, нужно будет перевыпускать токен.
* Токен долгоиграющий. В случае утечки у злоумышленника будет достаточно времени, чтобы им воспользоваться.
* Токен надо ротировать. Нужно регулярно перевыпускать токен и обновлять его в пайплайне, что есть дополнительная работа.

### App role
Этот метод чуть более продвинутый, теперь токен не постоянный, а генерируется в пайплайне, и его время жизни ограничено.
Инициализация может выглядеть так:
```bash
# создаем app role my-role и ограничиваем ее namespace my и политикой my-policy
bao write -namespace=my \ 
    auth/approle/role/my-role \
    token_policies="my-policy" \
    token_ttl=5m \
    token_max_ttl=30m
# создаем секрет для роли
bao write -ns=my -f auth/approle/role/my-role/secret-id

```
В переменных пайплайна теперь храним `role-id` и `secret-id`, а аутентификация и генерация токена теперь происходит так:

```bash
bao write -ns=my auth/approle/login role_id=$ROLE_ID secret_id=$SECRET_ID
```
**Улучшения по сравнению с предыдущим вариантом:**
- Токены не хранятся, а создаются каждый раз в пайплайне. В случае утечки токена, сам секрет не будет скомпроментирован
- Создаваемый токен имеет очень ограниченный срок действия.
**Недостатки:**
- Все еще надо хранить и ротировать секрет :(

### JWT токен
И наконец лучший вариант: использовать JWT токен. GitLab имеет супер полезную встроенную возможность генерировать в пайплайне JWT токен и вшивать в него детали пайплайна, такие как project id, pipeline id, environment и т. д. Secret provider такой как OpenBao

3. Использовать JWT токен. Как работает. Sequence diag. Лучше: ничего хранить не надо, токены временные. Идеально. Как сделать: команды, пайплайн

